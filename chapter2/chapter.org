* Exercise 2.82

Description: Show how to generalize ~apply-generic~ to handle coercion in the general case of
multiple arguments. One strategy is to attempt to coerce all the arguments to the type of the first
argument, then to the type of the second argument, and so on. Give an example of a situation where
this strategy (and likewise the two argument version given above) is not sufficiently general.
(Hint: Consider the case where there are some suitable mixed-type operations present in the table
that will not be tried).

#+BEGIN_SRC scheme
(load "/home/xdc/study/sicp/chapter2/2.81-coercion.scm")

(define (identity x) x)
(define (apply-generic . args)

  (define (inner op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (coercion-possible? type-tags)
                (let ((coercions (get-coercions type-tags)))
                  (if coercions
                      (apply inner (cons op (map (lambda (coercion value)
                                                   (coercion value))
                                                 coercions
                                                 args)))
                      (error "No method for these types" (list op type-tags))))
                (error "No method for these types" (list op type-tags)))))))

  ;; Types can be coerced as long as there are types to coerce and there is at least one type to
  ;; coerce
  (define (coercion-possible? types)
    (not (or
          (null? types)
          (every (lambda (type) (equal? type (car types))) types))))

  (define (get-coercions types)
    ;; Retrieves the coercion functions for each of the provided types, using (car base-types) as
    ;; the base type if a coercion function for all requested types from (car base-types) is not
    ;; found, then try with the next item in base-types until the list is exhausted.
    ;;
    ;; The first parameter is an ordered list of coercion functions.
    ;; The second parameter is a list of the remaining types in need of a coercion function
    ;; The third parameter is the list of base types we can use to attempt coercion
    (define (iter coercions to-coerce base-types)
      (cond ((null? to-coerce) coercions)
            ((null? base-types) (error "No method for these types" (list (types))))
            (else
             (let ((type (car to-coerce))
                   (base-type (car base-types)))
               (cond ((equal? type base-type)
                      (iter (append coercions (list identity))
                            (cdr to-coerce)
                            base-types))
                     ((get-coercion type base-type)
                      (iter (append coercions (list (get-coercion type base-type)))
                            (cdr to-coerce)
                            base-types))
                     (else (iter '() types (cdr base-types))))))))
    (iter '() types types))

  (apply inner args))

(define a (make-scheme-number 10))
(define b (make-complex-from-real-imag 9 19))
(add a b)

#+END_SRC

#+RESULTS:
: (complex rectangular 19 . 19)

* Exercise 2.83
Suppose you are designing a generic arithmetic system for dealing with the tower of types shown on
figure 2.25: integer, rational, real, complex. For each type (except complex), design a procedure
that raises objects of that type one level in the tower. Show how to install a generic ~raise~
operation that will work for each type (except complex).

#+BEGIN_SRC scheme
  (define (find-tuple-with-key tuple-list key)
    (cond ((null? tuple-list) #f)
          ((eq? (caar tuple-list) key) (car tuple-list))
          (else (find-tuple-with-key (cdr tuple-list) key))))

  (define (make-type-hierarchy)
    "We need a similar helper data structure to make-table, the difference here is that:
  1. Duplicates are not allowed
  2. A type can only have one ancestor
  3. The data structure is a list of tuples that have this composition: '(type super-type proc):
    a. type is the base type
    b. super-type is the ancestor type, a type can only have one ancestor.
    c. proc a procedure that transform from type to super-type"
    (let ((local-tuple-list '()))
      (define (get-tuple-list) local-tuple-list)
      (define (lookup type)
        (let ((tuple (find-tuple-with-key local-tuple-list type)))
          (if tuple
              tuple
              #f)))
      (define (insert! type super-type proc)
        (let ((tuple (lookup type)))
          (if tuple
              (error "Type ancestor already set" type)
              (set! local-tuple-list
                (cons (list type super-type proc) local-tuple-list)))))

      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              ((eq? m 'get-tuple-list) get-tuple-list)
              (else (error "Unknown operation -- TYPE-HIERARCHY" m))))
      dispatch))

  (define type-hierarchy (make-type-hierarchy))
  (define get-ancestor (type-hierarchy 'lookup-proc))
  (define put-ancestor (type-hierarchy 'insert-proc!))

  (define (raise value type target-type)
    (display '(value type target-type))
    (newline)
    (if (eq? type target-type)
        value
        (let ((ancestor (get-ancestor type)))
          (if ancestor
              (raise
               ((caddr ancestor) value)
               (cadr ancestor)
               target-type)
              (error "Type has no ancestors" type)))))

  ;; Just some silly convertion procedures, just to prove it works
  (put-ancestor 'integer 'rational (lambda (v) v))
  (put-ancestor 'rational 'real (lambda (v) v))
  (put-ancestor 'real 'complex (lambda (v) (* v 2)))

  (raise 5 'integer 'complex) ;; expected result is 10

#+END_SRC

#+RESULTS:
: 10
