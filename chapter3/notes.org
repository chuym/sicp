* Exercise 3.1
An accumulator is a procedure that is called repeatedly with a single numeric argument and
accumulates its arguments into a sum. Each time it is called, it returns the currently accumulated
sum. Write a procedure make-accumulator that generates accumulators, each maintaining an independent
sum. The input to make-accumulator should specify the initial value of the sum; for example.

#+BEGIN_SRC scheme :results output
  (define (make-accumulator a)
    (lambda (value)
      (set! a (+ value a))
      a))

  (define A (make-accumulator 5))
  (display (A 10))
  (newline)
  (display (A 10))
#+END_SRC

#+RESULTS:
: 15
: 25

* Exercise 3.2
 In software-testing applications, it is useful to be able to count the number of times a given
procedure is called during the course of a computation. Write a procedure make-monitored that takes
as input a procedure, f, that itself takes one input. The result returned by make-monitored is a
third procedure, say mf, that keeps track of the number of times it has been called by maintaining
an internal counter. If the input to mf is the special symbol how-many-calls?, then mf returns the
value of the counter. If the input is the special symbol reset-count, then mf resets the counter to
zero. For any other input, mf returns the result of calling f on that input and increments the
counter. For instance, we could make a monitored version of the sqrt procedure:

#+BEGIN_SRC scheme :results output
  (define (make-monitored f)
    (define call-count 0)

    (define (mf arg)
      (set! call-count (+ call-count 1))
      (f arg))

    (define (how-many-calls?) call-count)

    (define (reset-count)
      (set! call-count 0)
      call-count)

    (lambda (method)
      (cond ((eq? method 'how-many-calls?) (how-many-calls?))
            ((eq? method 'reset-count) (reset-count))
            (else (mf method)))))

  (define s (make-monitored sqrt))
  (display (s 100))
  (newline)
  (display (s 25))
  (newline)
  (display (s 'how-many-calls?))
  (newline)
  (s 'reset-count)
  (display (s 625))
  (newline)
  (display (s 'how-many-calls?))
#+END_SRC

#+RESULTS:
: 10
: 5
: 2
: 25
: 1
* Exercise 3.3
Modify the make-account procedure so that it creates password-protected accounts.

#+BEGIN_SRC scheme :results output
    (define (make-account balance password)

      (define (deposit amount)
        (cond ((< amount 0) (error "Cannot deposit a negative value"))
              (else
               (set! balance (+ balance amount))
               balance)))

      (define (withdraw amount)
        (cond ((< amount 0) (error "Cannot withdraw a negative value"))
              ((< balance amount) (error "Insufficient funds"))
              (else
               (set! balance (- balance amount))
               balance)))
      (lambda (provided-password method)
        (cond ((not (eq? password provided-password)) (error "Incorrect password"))
              ((eq? method 'withdraw) withdraw)
              ((eq? method 'deposit) deposit)
              (else "Bad method"))))

    (define acc (make-account 100 'secret-password))

    (display ((acc 'secret-password 'withdraw) 40))
    (newline)
    (display ((acc 'secret-password 'deposit) 15))
#+END_SRC

#+RESULTS:
: 60
: 75
* Exercise 3.4

Modify the make-account procedure of exercise 3.3 by adding another local state variable so that, if
an account is accessed more than seven consecutive times with an incorrect password, it invokes the
procedure call-the-cops.

#+BEGIN_SRC scheme :results output

  (define (make-account balance password)
    (define bad-password-given 0)

    (define (deposit amount)
      (cond ((< amount 0) (error "Cannot deposit a negative value"))
            (else
             (set! balance (+ balance amount))
             balance)))

    (define (withdraw amount)
      (cond ((< amount 0) (error "Cannot withdraw a negative value"))
            ((< balance amount) (error "Insufficient funds"))
            (else
             (set! balance (- balance amount))
             balance)))

    (define (incorrect-password)
      (cond ((>= bad-password-given 7) "Calling the cops!")
            (else
             (set! bad-password-given (+ bad-password-given 1))
             "Bad password given. Try again")))

    (lambda (provided-password method)
      (cond ((not (eq? password provided-password)) (lambda (v) (incorrect-password)))
            ((eq? method 'withdraw) withdraw)
            ((eq? method 'deposit) deposit)
            (else "Bad method"))))

  (define acc (make-account 100 'secret-password))

  (display ((acc 'secret-password 'withdraw) 40))
  (newline)
  (display ((acc 'secret-password 'deposit) 15))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
  (newline)
  (display ((acc 'bad-password 'withdraw) 50))
#+END_SRC

#+RESULTS:
#+begin_example
60
75
Bad password given. Try again
Bad password given. Try again
Bad password given. Try again
Bad password given. Try again
Bad password given. Try again
Bad password given. Try again
Bad password given. Try again
Calling the cops!
#+end_example

#+RESULTS: